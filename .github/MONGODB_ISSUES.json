[
  {
    "number": 1,
    "title": "[MongoDB] Fase 1.1: Evaluar y elegir tecnología MongoDB",
    "labels": ["feature/mongodb-support", "phase-1-research", "investigation"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nInvestigar y documentar las opciones disponibles para integrar MongoDB en Android:\n- Firebase Realtime Database\n- MongoDB Realm\n- MongoDB Atlas + REST API/GraphQL\n\n## Objetivos\n\n1. Crear documento comparativo de pros/contras de cada opción\n2. Realizar prueba de concepto (POC) con la opción recomendada\n3. Documentar la recomendación técnica justificada\n4. Identificar configuración básica necesaria\n\n## Criterios de Aceptación\n\n- [ ] Documento comparativo completado (Google Docs o Markdown)\n- [ ] POC funcional con la tecnología elegida\n- [ ] Configuración básica documentada\n- [ ] Decisión justificada según requisitos del proyecto\n- [ ] Documentación en `RESEARCH.md`\n\n## Estimación\n\n2-3 horas\n\n## Dependencias\n\nNinguna\n\n## Fase\n\nFase 1: Investigación e Infraestructura"
  },
  {
    "number": 2,
    "title": "[MongoDB] Fase 1.2: Configurar dependencias y SDK de MongoDB",
    "labels": ["feature/mongodb-support", "phase-1-research", "implementation"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nAgregar todas las dependencias necesarias al `build.gradle.kts` para soportar MongoDB según la tecnología elegida en la Issue #1.\n\n## Tareas\n\n1. Agregar SDK de MongoDB elegido (Realm, Firebase, etc.)\n2. Agregar librerías de serialización (GSON, Kotlinx Serialization, etc.)\n3. Agregar dependencias de red si es necesario (Retrofit, OkHttp, etc.)\n4. Configurar credenciales/claves de API (Firebase Config, MongoDB URI, etc.)\n5. Validar que la compilación sea exitosa\n\n## Cambios Esperados\n\n```kotlin\n// En app/build.gradle.kts\ndependencies {\n    // MongoDB/Realm o Firebase\n    // Agregar las dependencias elegidas\n}\n```\n\n## Criterios de Aceptación\n\n- [ ] Todas las dependencias están en `build.gradle.kts`\n- [ ] Proyecto compila sin errores\n- [ ] Configuración de credenciales documentada\n- [ ] Configuración no contiene secretos hardcodeados\n- [ ] Tests de compilación pasan\n\n## Estimación\n\n30 minutos - 1 hora\n\n## Dependencias\n\n- Issue #1 (decisión técnica)\n\n## Fase\n\nFase 1: Investigación e Infraestructura"
  },
  {
    "number": 3,
    "title": "[MongoDB] Fase 2.1: Crear modelo de datos MongoDB",
    "labels": ["feature/mongodb-support", "phase-2-modeling", "implementation"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nDefinir esquema de datos en MongoDB compatible con la estructura actual de la aplicación. Crear data classes y convertidores necesarios.\n\n## Tareas\n\n1. Crear `DatosMongoDBRecord` (o clase compatible con Realm/Firebase)\n2. Definir mapeos entre `Record` y formato MongoDB/Realm\n3. Crear convertidores de serialización (Date a String/Long/Timestamp)\n4. Documentar esquema esperado en MongoDB\n5. Agregar validaciones de datos\n\n## Estructura de Ejemplo\n\n```kotlin\n// En app/src/main/java/com/SarayDani/sidi/ParaRoom/MongoDBModels.kt\n@RealmObject\nclass DatosMongoDBRecord {\n    var id: ObjectId = ObjectId()\n    var record: Int = 0\n    var fecha: Long = 0L  // Timestamp\n    var sincronizado: Boolean = false\n    var ultimaSincronizacion: Long = 0L\n}\n```\n\n## Criterios de Aceptación\n\n- [ ] Data class MongoDB creado y documentado\n- [ ] Convertidores implementados correctamente\n- [ ] Mapeo bidireccional entre `Record` y `DatosMongoDBRecord`\n- [ ] Validaciones de datos implementadas\n- [ ] Tests unitarios para convertidores pasan\n- [ ] Documentación de esquema en comentarios\n\n## Estimación\n\n1-2 horas\n\n## Dependencias\n\n- Issue #1 (decisión técnica)\n- Issue #2 (dependencias configuradas)\n\n## Fase\n\nFase 2: Modelado de Datos y Arquitectura"
  },
  {
    "number": 4,
    "title": "[MongoDB] Fase 2.2: Implementar clase ConexionMongoDB",
    "labels": ["feature/mongodb-support", "phase-2-modeling", "implementation"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nCrear nueva implementación de la interfaz `Conexion` para MongoDB. Esta clase será la responsable de todas las operaciones de lectura/escritura con MongoDB.\n\n## Tareas\n\n1. Crear clase `ConexionMongoDB` que implementa `Conexion`\n2. Implementar método `obtenerRecord(context: Context): Record`\n3. Implementar método `actualizarRecord(nuevoRecord, fecha, context): Record`\n4. Agregar manejo robusto de excepciones\n5. Implementar logging de operaciones\n6. Optimizar querys a MongoDB\n\n## Estructura Esperada\n\n```kotlin\n// En app/src/main/java/com/SarayDani/sidi/ConexionMongoDB.kt\nclass ConexionMongoDB : Conexion {\n    override fun obtenerRecord(context: Context): Record {\n        // Obtener de MongoDB/Realm\n    }\n    \n    override fun actualizarRecord(\n        nuevoRecord: Int,\n        fecha: Date,\n        context: Context\n    ): Record {\n        // Actualizar en MongoDB/Realm\n    }\n}\n```\n\n## Criterios de Aceptación\n\n- [ ] Clase `ConexionMongoDB` implementa correctamente la interfaz `Conexion`\n- [ ] Método `obtenerRecord()` funciona correctamente\n- [ ] Método `actualizarRecord()` funciona correctamente\n- [ ] Manejo de errores implementado (try-catch, logging)\n- [ ] Logging de operaciones para debugging\n- [ ] Tests unitarios con mocks pasan\n- [ ] Sin hardcoding de credenciales\n\n## Estimación\n\n2-3 horas\n\n## Dependencias\n\n- Issue #3 (modelo de datos)\n\n## Fase\n\nFase 2: Modelado de Datos y Arquitectura"
  },
  {
    "number": 5,
    "title": "[MongoDB] Fase 2.3: Implementar caché local y sincronización offline-first",
    "labels": ["feature/mongodb-support", "phase-2-modeling", "implementation"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nCrear sistema de sincronización asincrónica que funcione correctamente sin conexión a internet. Los cambios se guardan localmente y se sincronizan cuando hay conexión.\n\n## Tareas\n\n1. Crear clase `SincronizadorMongoDB` para gestionar sincronización\n2. Implementar detección de conectividad (ConnectionManager)\n3. Crear cola de operaciones pendientes de sincronización\n4. Implementar sincronización periódica cuando hay conexión\n5. Resolver conflictos de sincronización (last-write-wins)\n6. Notificar estado de sincronización a la UI\n7. Implementar reintentos automáticos con backoff exponencial\n\n## Arquitectura\n\n```kotlin\n// En app/src/main/java/com/SarayDani/sidi/SincronizadorMongoDB.kt\nclass SincronizadorMongoDB(\n    private val conexionLocal: Conexion,  // SQLite como caché\n    private val conexionMongoDB: ConexionMongoDB\n) {\n    fun sincronizar(): Flow<EstadoSincronizacion>\n    fun guardarConSincronizacion(record: Record): Flow<Resultado>\n}\n\nenum class EstadoSincronizacion {\n    PENDIENTE, SINCRONIZANDO, COMPLETADO, ERROR\n}\n```\n\n## Criterios de Aceptación\n\n- [ ] Sincronización offline-first funciona correctamente\n- [ ] Cola de operaciones persiste y restaura correctamente\n- [ ] Detección de conectividad funciona\n- [ ] Conflictos se resuelven correctamente\n- [ ] Estado de sincronización se emite como Flow\n- [ ] Reintentos con backoff exponencial implementados\n- [ ] Tests de sincronización con/sin conexión pasan\n- [ ] Sin pérdida de datos en sincronización\n\n## Estimación\n\n3-4 horas\n\n## Dependencias\n\n- Issue #3 (modelo de datos)\n- Issue #4 (ConexionMongoDB)\n\n## Fase\n\nFase 2: Modelado de Datos y Arquitectura"
  },
  {
    "number": 6,
    "title": "[MongoDB] Fase 3.1: Crear ConexionFactory para selector de implementación",
    "labels": ["feature/mongodb-support", "phase-3-integration", "architecture"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nRefactorizar el sistema para permitir cambiar dinámicamente entre Shared Preferences, SQLite y MongoDB sin modificar el código de negocio.\n\n## Tareas\n\n1. Crear enumerado `TipoConexion` con las opciones disponibles\n2. Crear clase `ConexionFactory` con patrón Factory\n3. Refactorizar `Controller` para usar factory\n4. Agregar selector de tipo de conexión a preferencias de app\n5. Permitir cambio de tipo en tiempo de ejecución\n6. Documen arquitectura en comentarios\n\n## Estructura Esperada\n\n```kotlin\n// En app/src/main/java/com/SarayDani/sidi/ConexionFactory.kt\nenum class TipoConexion {\n    SHARED_PREFERENCES,\n    SQLITE,\n    MONGODB\n}\n\nobject ConexionFactory {\n    fun crearConexion(\n        tipo: TipoConexion,\n        context: Context\n    ): Conexion {\n        return when (tipo) {\n            TipoConexion.SHARED_PREFERENCES -> ControllerSharedPreferences()\n            TipoConexion.SQLITE -> ControllerRoom()\n            TipoConexion.MONGODB -> ConexionMongoDB()\n        }\n    }\n}\n```\n\n## Cambios en MyViewModel\n\n- [ ] Agregar variable `tipoConexionActual: TipoConexion`\n- [ ] Usar factory para crear instancia de conexión\n- [ ] Permitir cambio de tipo mediante función pública\n- [ ] Persistir selección en SharedPreferences\n\n## Criterios de Aceptación\n\n- [ ] ConexionFactory implementado correctamente\n- [ ] Cambio entre conexiones funciona sin errores\n- [ ] Tipo de conexión se persiste en preferencias\n- [ ] MyViewModel usa factory correctamente\n- [ ] Tests de factory pasan\n- [ ] Documentación de uso en comentarios\n\n## Estimación\n\n2-3 horas\n\n## Dependencias\n\n- Issue #4 (ConexionMongoDB)\n\n## Fase\n\nFase 3: Integración y Configuración"
  },
  {
    "number": 7,
    "title": "[MongoDB] Fase 3.2: Agregar UI para seleccionar tipo de conexión",
    "labels": ["feature/mongodb-support", "phase-3-integration", "ui"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nCrear interfaz de usuario para permitir al usuario seleccionar el tipo de persistencia que desea usar y ver el estado de sincronización.\n\n## Tareas\n\n1. Agregar selector de tipo de conexión en la UI (RadioButton, DropDown, etc.)\n2. Mostrar estado actual de sincronización si es MongoDB\n3. Opción para forzar sincronización manual\n4. Indicador visual del tipo de conexión activo\n5. Mostrar última sincronización exitosa (para MongoDB)\n\n## Especificaciones de UI\n\n- Ubicación: Menú de configuración o panel de información\n- Selector: RadioButtons para las 3 opciones\n- Estado: Indicador con color (verde=activo, rojo=error, amarillo=sincronizando)\n- Botón de sincronización manual para MongoDB\n- Textos en español según el proyecto\n\n## Criterios de Aceptación\n\n- [ ] Selector de conexión visible en UI\n- [ ] Cambio de tipo funciona desde UI\n- [ ] Estado de sincronización se muestra correctamente\n- [ ] Botón de sincronización manual funciona\n- [ ] Indicadores visuales son claros\n- [ ] Textos en español\n- [ ] UI es responsive y usable\n- [ ] Tests de UI pasan\n\n## Estimación\n\n1-2 horas\n\n## Dependencias\n\n- Issue #6 (ConexionFactory)\n\n## Fase\n\nFase 3: Integración y Configuración"
  },
  {
    "number": 8,
    "title": "[MongoDB] Fase 4.1: Implementar tests unitarios para ConexionMongoDB",
    "labels": ["feature/mongodb-support", "phase-4-testing", "testing"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nCrear suite completa de tests unitarios para `ConexionMongoDB` usando mocks de MongoDB/Realm.\n\n## Tareas\n\n1. Crear archivo `ConexionMongoDBTest.kt` en `app/src/test/`\n2. Implementar mocks de MongoDB/Realm\n3. Escribir tests para cada caso de uso\n4. Implementar tests de manejo de excepciones\n5. Implementar tests de validación de datos\n6. Agregar tests de rendimiento\n\n## Casos de Prueba\n\n```kotlin\n// En app/src/test/java/com/SarayDani/sidi/ConexionMongoDBTest.kt\nclass ConexionMongoDBTest {\n    @Test\n    fun `obtenerRecord devuelve record existente`()\n    \n    @Test\n    fun `obtenerRecord retorna record por defecto cuando no existe`()\n    \n    @Test\n    fun `actualizarRecord guarda correctamente`()\n    \n    @Test\n    fun `actualizarRecord actualiza fecha correctamente`()\n    \n    @Test\n    fun `obtenerRecord maneja excepciones de conexión`()\n    \n    @Test\n    fun `actualizarRecord maneja datos inválidos`()\n    \n    @Test\n    fun `sincronización offline funciona correctamente`()\n}\n```\n\n## Criterios de Aceptación\n\n- [ ] Coverage > 80% de `ConexionMongoDB`\n- [ ] Todos los tests pasan\n- [ ] Tests usan mocks apropiados\n- [ ] Tests son independientes y reproducibles\n- [ ] Documentación de tests en comentarios\n- [ ] Tests se ejecutan rápidamente (< 5 segundos)\n- [ ] No hay dependencias externas en tests unitarios\n\n## Estimación\n\n2-3 horas\n\n## Dependencias\n\n- Issue #4 (ConexionMongoDB)\n- Issue #5 (SincronizadorMongoDB)\n\n## Fase\n\nFase 4: Testing"
  },
  {
    "number": 9,
    "title": "[MongoDB] Fase 4.2: Implementar tests instrumented para sincronización MongoDB",
    "labels": ["feature/mongodb-support", "phase-4-testing", "testing"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nCrear suite de tests Android reales con emulador/dispositivo para validar la sincronización MongoDB en condiciones reales.\n\n## Tareas\n\n1. Crear archivo `MongoDBSyncTest.kt` en `app/src/androidTest/`\n2. Implementar tests con contexto Android real\n3. Simular desconexión de red (mediante mock)\n4. Validar persistencia en SQLite durante offline\n5. Validar sincronización automática cuando regresa conexión\n6. Tests de resolución de conflictos\n7. Tests de rendimiento\n\n## Casos de Prueba\n\n```kotlin\n// En app/src/androidTest/java/com/SarayDani/sidi/MongoDBSyncTest.kt\nclass MongoDBSyncTest {\n    @Test\n    fun `sincronización con conexión activa funciona`()\n    \n    @Test\n    fun `guardar sin conexión persiste localmente`()\n    \n    @Test\n    fun `sincronización automática cuando regresa conexión`()\n    \n    @Test\n    fun `conflictos se resuelven correctamente`()\n    \n    @Test\n    fun `migración de datos locales a remoto funciona`()\n    \n    @Test\n    fun `rendimiento con múltiples operaciones es aceptable`()\n}\n```\n\n## Criterios de Aceptación\n\n- [ ] Todos los tests instrumented pasan\n- [ ] Tests se ejecutan exitosamente en emulador Android\n- [ ] Sincronización sin conexión funciona correctamente\n- [ ] Sincronización automática se dispara correctamente\n- [ ] Conflictos se resuelven sin pérdida de datos\n- [ ] Rendimiento es aceptable (< 2s por operación)\n- [ ] Documentación de tests en comentarios\n- [ ] Tests son reproducibles\n\n## Estimación\n\n3-4 horas\n\n## Dependencias\n\n- Issue #5 (SincronizadorMongoDB)\n- Issue #8 (Tests unitarios)\n\n## Fase\n\nFase 4: Testing"
  },
  {
    "number": 10,
    "title": "[MongoDB] Fase 5.1: Crear herramienta de migración de datos",
    "labels": ["feature/mongodb-support", "phase-5-migration", "implementation"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nCrear herramienta para migrar datos existentes de Shared Preferences y SQLite a MongoDB de manera segura.\n\n## Tareas\n\n1. Crear clase `MigradorMongoDB`\n2. Implementar lectura de datos de Shared Preferences\n3. Implementar lectura de datos de SQLite (Room)\n4. Implementar migración a MongoDB con validación\n5. Agregar opción de mantener datos locales como backup\n6. Implementar logging detallado de progreso\n7. Crear UI para iniciar migración\n\n## Estructura Esperada\n\n```kotlin\n// En app/src/main/java/com/SarayDani/sidi/MigradorMongoDB.kt\nclass MigradorMongoDB(\n    private val conexionLocal: Conexion,\n    private val conexionMongoDB: ConexionMongoDB\n) {\n    fun migrar(): Flow<ProgresioMigracion>\n    fun verificarDatos(): Boolean\n}\n\ndata class ProgresioMigracion(\n    val progreso: Int,  // 0-100\n    val mensaje: String,\n    val error: Exception?\n)\n```\n\n## Criterios de Aceptación\n\n- [ ] Migración desde Shared Preferences funciona\n- [ ] Migración desde SQLite funciona\n- [ ] Validación de datos post-migración implementada\n- [ ] Backup automático antes de migración\n- [ ] Logging detallado de cada paso\n- [ ] Manejo de errores y rollback si es necesario\n- [ ] UI intuitiva para iniciar migración\n- [ ] Tests de migración pasan\n- [ ] Sin pérdida de datos\n- [ ] Historial de migraciones disponible\n\n## Estimación\n\n2-3 horas\n\n## Dependencias\n\n- Issue #4 (ConexionMongoDB)\n- Issue #6 (ConexionFactory)\n\n## Fase\n\nFase 5: Migración y Documentación"
  },
  {
    "number": 11,
    "title": "[MongoDB] Fase 5.2: Documentar arquitectura MongoDB en README",
    "labels": ["feature/mongodb-support", "phase-5-migration", "documentation"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nActualizar la documentación del proyecto para incluir la nueva arquitectura de persistencia con MongoDB.\n\n## Tareas\n\n1. Agregar sección \"Persistencia de Datos\" al README.md\n2. Crear documento ARCHITECTURE.md con diagrama de capas\n3. Explicar las tres opciones de almacenamiento\n4. Documentar decisiones de diseño\n5. Crear guía de configuración para desarrolladores\n6. Escribir ejemplos de uso de ConexionFactory\n7. Documentar sincronización offline-first\n8. Agregar diagrama de flujo de sincronización\n\n## Archivos a Actualizar\n\n- `README.md` - Sección de persistencia y arquitectura\n- `ARCHITECTURE.md` - Nuevo documento técnico\n- `FEATURE_MONGODB.md` - Ya existe, actualizar con enlaces\n- Comentarios en código fuente\n\n## Contenido Esperado\n\n- Diagrama arquitectura de capas\n- Explicación de cada implementación de Conexion\n- Flujo de sincronización offline-first\n- Guía de configuración (API keys, URIs, etc.)\n- Ejemplos de código\n- Performance considerations\n- Security best practices\n\n## Criterios de Aceptación\n\n- [ ] README.md actualizado con sección de persistencia\n- [ ] ARCHITECTURE.md creado con diagramas\n- [ ] Documentación clara y en español\n- [ ] Ejemplos de código funcionales\n- [ ] Diagramas (mermaid o imágenes) generados\n- [ ] Enlaces entre documentos funcionan\n- [ ] Documentación es fácil de navegar\n- [ ] Code comments actualizados\n\n## Estimación\n\n2 horas\n\n## Dependencias\n\n- Todas las issues previas (1-10)\n\n## Fase\n\nFase 5: Migración y Documentación"
  },
  {
    "number": 12,
    "title": "[MongoDB] Fase 6: Merge a rama develop y crear release",
    "labels": ["feature/mongodb-support", "phase-6-release", "release"],
    "assignee": null,
    "milestone": "MongoDB Integration v1.0",
    "body": "## Descripción\n\nIntegración final del feature MongoDB siguiendo el flujo gitflow del proyecto.\n\n## Tareas\n\n1. Crear rama `feature/mongodb-support` desde `develop` (si no existe)\n2. Merge de todas las ramas feature en `feature/mongodb-support`\n3. Resolver conflictos de merge si existen\n4. Crear Pull Request a `develop`\n5. Code review y solicitar ajustes\n6. Merge a `develop`\n7. Crear rama `release/1.1.0` desde `develop`\n8. Actualizar versionado en `gradle.properties`\n9. Actualizar CHANGELOG.md\n10. Merge de `release/1.1.0` a `main`\n11. Crear tag de release `v1.1.0`\n12. Merge back de `release/1.1.0` a `develop`\n\n## Cambios de Versionado\n\n```properties\n# En gradle.properties\nversionCode = 2\nversionName = 1.1.0\n```\n\n## Actualizar CHANGELOG.md\n\n```markdown\n## [1.1.0] - 2026-01-19\n\n### Added\n- Soporte para MongoDB como opción de persistencia\n- Sincronización offline-first\n- ConexionFactory para selector de almacenamiento\n- UI para cambiar tipo de persistencia\n- Herramienta de migración de datos\n\n### Changed\n- Refactorización de Controller para usar factory\n- Documentación actualizada\n```\n\n## Criterios de Aceptación\n\n- [ ] Rama `feature/mongodb-support` existe y es estable\n- [ ] Pull Request a `develop` creado\n- [ ] Code review completado\n- [ ] Todos los tests pasan en CI/CD\n- [ ] Rama `release/1.1.0` creada\n- [ ] Versionado actualizado a 1.1.0\n- [ ] CHANGELOG.md actualizado\n- [ ] Tag de release creado\n- [ ] Merge a `main` completado\n- [ ] Merge back a `develop` completado\n- [ ] Release notes publicadas\n\n## Estimación\n\n1-2 horas\n\n## Dependencias\n\n- Todas las issues previas (1-11 completadas)\n\n## Fase\n\nFase 6: Integración Final\n\n## Notas\n\nSeguir el flujo gitflow documentado en `.github/copilot-instructions.md`:\n- `feature/nombre-descriptivo` para desarrollo\n- `develop` para integración continua\n- `release/x.y` para versiones estables\n- `main` para producción"
  }
]

